# TPS를 포함하는 성능 테스트 이론

성능 테스트의 가장 기초가 되는 수학적 원리가 바로 **리틀의 법칙(Little's Law)**입니다. 이 법칙은 시스템 내부에 머무는 사용자 수와 처리량, 응답 시간 사이의 상관관계를 설명하며, 복잡한 시스템의 성능을 단순하고 명확하게 계산할 수 있게 해줍니다.

## TPS 핵심 지표 타임라인

아래 다이어그램은 사용자 요청 한 사이클에서 측정되는 핵심 지표들의 관계를 보여줍니다.

```mermaid
flowchart LR
    C1[Click 1] --> R1[Request] --> P1[Processing] --> RS1[Response]
    RS1 --> T1[Think Time]
    T1 --> C2[Click 2] --> R2[Request] --> P2[Processing] --> RS2[Response]
```

### 지표 설명

| 지표 | 설명 | JMeter 설정 |
|------|------|-------------|
| **Click Point** | 사용자가 실제로 요청을 보내는 시점 (버튼 클릭, 페이지 이동 등) | Sampler 실행 시점 |
| **Response Time** | 요청을 보낸 후 응답을 받기까지 걸린 시간. 서버의 처리 능력을 나타냄 | 자동 측정됨 |
| **Think Time** | 응답을 받은 후 다음 요청을 보내기까지 사용자가 대기하는 시간 | Timer (Constant Timer, Gaussian Timer 등) |
| **Request Interval** | 한 요청부터 다음 요청까지의 전체 간격 = Response Time + Think Time | - |

### TPS 계산 공식

$$TPS = \frac{Active\ Users}{Request\ Interval} = \frac{Active\ Users}{Response\ Time + Think\ Time}$$

:::info
**예시**: 10명의 동시 사용자가 있고, 평균 응답 시간 0.5초, Think Time 1.5초라면:
- Request Interval = 0.5 + 1.5 = 2초
- TPS = 10 / 2 = **5 TPS**
:::

---

## 1. 리틀의 법칙 공식

$$L = \lambda \times W$$

이 공식을 성능 테스트 용어로 치환하면 다음과 같습니다.

$$Active\ User (VU) = TPS \times Response\ Time$$

- $L$ (Lead Time / Active User): 시스템 안에 머무르고 있는 평균 사용자 수 (액티브 유저).
- $\lambda$ (Arrival Rate / TPS): 단위 시간당 시스템에 들어오는(또는 나가는) 평균 요청 수 (처리량).
- $W$ (Wait Time / Response Time): 사용자가 시스템에 머무는 평균 시간 (응답 시간).

## 2. 왜 리틀의 법칙이 중요한가?

성능 테스트 중에 우리가 측정하는 세 가지 핵심 지표는 서로 독립적이지 않습니다. 하나의 수치가 변하면 반드시 다른 수치에 영향을 줍니다.

- **동시 사용자 수 예측**: 목표 TPS가 100이고 예상 응답 시간이 2초라면, 서버는 항상 최소 200명의 액티브 유저($100 \times 2$)를 감당할 수 있는 자원(Thread, DB Connection 등)을 확보하고 있어야 합니다.
- **병목 현상 진단**: 시스템의 처리량(TPS)이 고정되어 있는데 응답 시간($W$)이 길어진다면, 시스템 내의 액티브 유저($L$)가 증가하게 됩니다. 이는 결국 **대기열(Queue)**이 쌓이고 있다는 증거입니다.
- **테스트 설계의 타당성 검증**: JMeter에서 500개의 스레드를 돌렸는데 TPS가 50, 응답 시간이 10초가 나왔다면 $50 \times 10 = 500$으로 리틀의 법칙이 성립합니다. 만약 이 수치가 맞지 않는다면 테스트 환경이나 측정 방식에 오류가 있는 것입니다.

## 3. 실전 예시 (t3.medium 환경)

어느 쇼핑몰의 결제 API 성능을 테스트한다고 가정해 봅시다.

- **상황 A (정상)**: 응답 시간이 0.5초이고 서버가 초당 20건(TPS)을 처리한다면, 서버에는 항상 10명($20 \times 0.5$)의 액티브 유저가 있습니다.
- **상황 B (지연 발생)**: DB 부하로 인해 응답 시간이 5초로 늘어났는데, 유입되는 요청(TPS)이 여전히 20건이라면, 서버에는 100명($20 \times 5$)의 액티브 유저가 쌓이게 됩니다.
- **결과**: t3.medium 서버의 Thread Pool 설정이 50개라면, 상황 A는 문제가 없지만 상황 B에서는 50명을 제외한 나머지 50명은 응답을 받지 못하고 무한 대기하거나 에러(503 Service Unavailable)를 겪게 됩니다.

## 4. 리틀의 법칙과 Saturation Point

시스템이 **Saturation Point(포화 지점)**에 도달하면 리틀의 법칙에 의해 다음과 같은 현상이 발생합니다.

- 자원(CPU, Thread 등)이 꽉 차서 TPS($\lambda$)가 더 이상 증가하지 못함.
- 하지만 유입되는 사용자는 계속 늘어나므로 액티브 유저($L$)는 계속 증가.
- 공식($L = \lambda \times W$)을 유지하기 위해 응답 시간($W$)이 기하급수적으로 증가.

## 💡 요약

리틀의 법칙은 **"서버가 수용할 수 있는 액티브 유저의 한계는 이미 정해져 있으며, 응답 시간이 길어지면 그만큼 처리할 수 있는 유저 수는 줄어든다"**는 것을 수학적으로 증명합니다.

---

## 5. 성능 테스트 분류

성능 테스트는 크게 **목적(Why)**에 의한 분류와 **방법(How)**에 의한 분류로 나눌 수 있습니다.

### 5.1 목적에 의한 분류 (Why)

테스트를 통해 얻고자 하는 **비즈니스 목표**나 **시스템의 안정성 검증 범위**에 따른 분류입니다.

| 분류 | 특징 및 목적 | 비유 |
|------|-------------|------|
| **Load Test** (부하 테스트) | 시스템의 예상 최대 부하 내에서 정상 동작 여부를 확인합니다. 응답 시간과 TPS의 기준치를 충족하는지 검증합니다. | "우리 식당에 손님이 꽉 찼을 때 음식이 늦지 않게 나가는가?" |
| **Stress Test** (스트레스 테스트) | 임계치 이상의 부하를 가해 시스템이 언제, 어떻게 무너지는지 확인합니다. 장애 발생 후 복구(Failover) 능력도 함께 봅니다. | "손님이 입구까지 줄을 섰을 때 주방이 마비되는가, 아니면 순차적으로 처리하는가?" |
| **Endurance Test** (내구 테스트) | 장시간(8~24시간 이상) 일정한 부하를 유지하여 메모리 누수(Memory Leak)나 자원 고갈 현상을 추적합니다. | "식당을 24시간 연중무휴로 운영해도 주방 장비가 고장 나지 않는가?" |
| **Scalability Test** (확장성 테스트) | 서버 사양을 높이거나(Scale-up) 대수를 늘릴 때(Scale-out) 성능이 비례해서 향상되는지 측정합니다. | "주방장을 한 명 더 고용하면 음식 나가는 속도가 2배로 빨라지는가?" |

### 5.2 방법에 의한 분류 (How)

**수행하는 방법론**의 관점에서 분류하면, 시스템이 특정 상황(폭증, 장시간 유지, 자원 확장 등)에서 어떻게 반응하는지를 **기술적으로 검증**하는 데 초점을 맞추게 됩니다.

#### 1) 루프백 테스트 (Loopback Test)

네트워크나 서버의 가장 기초적인 성능을 확인하기 위해, 실제 비즈니스 로직을 타지 않고 입출력만을 반복하는 방법입니다.

- **방법**: 애플리케이션의 복잡한 로직(DB 조회, 연산 등)을 거치지 않고, 단순히 "OK" 응답만 주는 엔드포인트를 호출하거나 자기 자신에게 패킷을 보내 돌아오는 시간을 측정합니다.
- **목적**: 네트워크 대역폭 자체의 한계나, 웹 서버(Nginx, Apache 등) 설정 자체의 병목이 없는지 기초 체력을 테스트합니다. 로직 테스트 전 "고속도로 자체가 막히지는 않았는지" 확인하는 과정입니다.

#### 2) 스파이크 테스트 (Spike Test)

단시간 내에 사용자가 기하급수적으로 폭증했다가 다시 급격히 빠지는 상황을 재현하는 방법입니다.

- **방법**: 평상시 부하를 유지하다가, 특정 시점에 수 초 내로 목표 최대 부하까지 수직으로 끌어올린 후 일정 시간 유지하고 다시 급격히 낮춥니다.
- **목적**: 티켓 예매 오픈, 선착순 이벤트, 방송 노출 시의 찰나의 부하를 견딜 수 있는지 확인합니다. 이 테스트를 통해 서버의 자동 확장(Auto-scaling) 속도가 부하 증가 속도를 따라가는지, 혹은 시스템이 뻗지 않고 대기열(Queue)을 적절히 생성하는지 검증합니다.

#### 3) 확장성 테스트 (Scalability Test)

시스템의 자원(CPU, RAM)을 늘리거나 서버 대수를 늘릴 때 성능이 얼마나 효율적으로 비례 상승하는지 확인하는 방법입니다.

- **방법**: 하드웨어 사양을 높이거나(Scale-up), 서버를 1대에서 2대, 4대로 늘려가며(Scale-out) 동일한 시나리오로 반복 테스트합니다.
- **목적**: 투자한 비용(인프라 증설)만큼 성능이 정비례해서 올라가는지 확인합니다. 만약 서버를 2배로 늘렸는데 TPS가 1.2배만 증가한다면, DB Lock이나 네트워크 스위치 등 다른 곳에 숨은 병목이 있음을 의미합니다.

#### 4) 가용성 테스트 (Availability Test)

시스템이 장애 상황에서도 중단 없이 서비스를 제공할 수 있는지, 즉 '얼마나 믿음직한가'를 확인하는 방법입니다.

- **방법**: 부하가 가해지고 있는 상황에서 의도적으로 특정 서버 프로세스를 죽이거나, 네트워크 선을 차단하거나, DB 인스턴스를 재시작합니다.
- **목적**: 장애 발생 시 이중화된 장비로 즉시 전환(Failover)되는지, 데이터 유실은 없는지 확인합니다. 또한, 장시간 부하를 주는 **내구 테스트(Endurance Test)**의 성격을 포함하여, 오래 가동했을 때 메모리 누수나 로그 파일 비대화로 인해 시스템이 멈추지 않는지 검증합니다.

### 5.2 방법에 의한 분류 (How) - 상세 표

**수행하는 방법론**의 관점에서 분류하면, 시스템이 특정 상황(폭증, 장시간 유지, 자원 확장 등)에서 어떻게 반응하는지를 **기술적으로 검증**하는 데 초점을 맞추게 됩니다. 아래 표는 4가지 주요 방법을 요약한 것입니다.

| 분류 | 설명 | 사용 예시 |
|------|------|----------|
| **루프백 테스트** (Loopback Test) | 네트워크나 서버의 가장 기초적인 성능을 확인하기 위해, 실제 비즈니스 로직을 타지 않고 입출력만을 반복하는 방법입니다. | 단순한 "OK" 응답만 주는 엔드포인트를 호출하거나 자기 자신에게 패킷을 보내 돌아오는 시간을 측정. 웹 서버(Nginx, Apache 등) 설정 자체의 병목이 없는지 기초 체력을 테스트. |
| **스파이크 테스트** (Spike Test) | 단시간 내에 사용자가 기하급수적으로 폭증했다가 다시 급격히 빠지는 상황을 재현하는 방법입니다. | 티켓 예매 오픈, 선착순 이벤트, 방송 노출 시의 찰나의 부하를 견딜 수 있는지 확인. 서버의 자동 확장(Auto-scaling) 속도가 부하 증가 속도를 따라가는지, 혹은 시스템이 뻗지 않고 대기열(Queue)을 적절히 생성하는지 검증. |
| **확장성 테스트** (Scalability Test) | 서버 사양을 높이거나(Scale-up) 대수를 늘릴 때(Scale-out) 성능이 비례해서 향상되는지 측정합니다. | 하드웨어 사양을 높이거나(Scale-up), 서버를 1대에서 2대, 4대로 늘려가며(Scale-out) 동일한 시나리오로 반복 테스트. 투자한 비용(인프라 증설)만큼 성능이 정비례해서 올라가는지 확인. |
| **가용성 테스트** (Availability Test) | 시스템이 장애 상황에서도 중단 없이 서비스를 제공할 수 있는지, 즉 '얼마나 믿음직한가'를 확인하는 방법입니다. | 부하가 가해지고 있는 상황에서 의도적으로 특정 서버 프로세스를 쌓이거나, 네트워크 선을 차단하거나, DB 인스턴스를 재시작. 장애 발생 시 이중화된 장비로 즉시 전환(Failover)되는지, 데이터 유실은 없는지 확인. |

### 5.3 실전 분석 팁 (with Scouter)

- **스파이크 테스트 시**: Scouter의 Active Service 그래프가 수직으로 솟구칠 때, 응답 시간(XLog)이 비정상적으로 길어지는 구간을 찾아 '임계 시간'을 설정하는 근거로 삼으세요.
- **가용성 테스트 시**: 서버 한 대가 죽었을 때 나머지 서버들의 CPU/Memory가 급격히 상승하는지 관찰하여, 최소 필요 서버 대수를 산정하세요.