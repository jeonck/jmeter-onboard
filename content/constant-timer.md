# JMeter Constant Timer 활용

JMeter에서 Constant Timer는 가상 사용자(Thread)가 다음 요청을 보내기 전에 일정한 시간 동안 대기하도록 만드는 '지연 시간(Think Time)' 도구입니다.

현실적인 부하 테스트를 위해서는 서버에 쉴 새 없이 요청을 퍼붓는 것이 아니라, 실제 사람이 화면을 보고 클릭하는 시간 간격을 재현해야 하는데 이때 가장 기본적으로 사용됩니다.

## 1. 주요 기능 및 설정

설정은 아주 단순합니다. 단 하나의 파라미터만 존재합니다.

- **Thread Delay (milliseconds)**: 지연시키고 싶은 시간을 밀리초(ms) 단위로 입력합니다.
  - 예: 3000 입력 시 다음 샘플러 실행 전 3초간 대기.

## 2. Constant Timer의 독특한 동작 방식 (Scope)

JMeter에서 타이머는 다른 요소들과 동작 방식이 달라 주의가 필요합니다.

- **실행 순서**: 타이머는 샘플러(HTTP Request 등)보다 앞에 위치하든 뒤에 위치하든 상관없이, 해당 스코프 내의 샘플러가 실행되기 직전에 동작합니다.

- **적용 범위**:
  - 특정 요청 아래에 배치: 해당 요청 직전에만 대기합니다.
  - Thread Group 바로 아래에 배치: 해당 그룹 내의 모든 요청 직전에 매번 설정한 시간만큼 대기합니다.

## 3. 현실적인 부하 테스트를 위한 활용 팁

### ① Think Time의 재현

실제 사용자는 메인 페이지를 열자마자 0.1초 만에 로그인 버튼을 누르지 않습니다. 페이지 내용을 훑어보는 시간(Think Time)을 Constant Timer로 부여하면, 서버에 가해지는 **초당 처리량(Throughput)**을 조절하여 실제 상황과 유사한 부하를 만들 수 있습니다.

### ② 서버 자원 회복 시간 부여 (t3.medium 환경)

t3.medium처럼 사양이 낮은 서버에서 테스트할 때, 타이머 없이 요청을 쏘면 서버가 응답을 처리하기도 전에 다음 요청이 쌓여 금방 뻗어버릴 수 있습니다. 1~2초의 지연 시간을 주면 서버가 이전 요청을 처리하고 자원을 정리할 여유를 주면서 안정적인 테스트가 가능합니다.

### ③ Scouter와의 연계 분석

- **타이머가 없을 때**: Scouter XLog에 점들이 수직 기둥처럼 빽빽하게 찍히며 CPU가 요동칩니다.
- **타이머가 있을 때**: XLog의 점들이 시간 간격을 두고 퍼지며, 서버의 Active Service 수치가 완만하게 유지되는 것을 확인할 수 있습니다.

## ⚠️ 주의사항: "모든 요청에 적용됨"

Thread Group 최상단에 Constant Timer를 무심코 넣어두면, 모든 이미지 호출과 API 요청 사이에 수 초의 대기가 발생하여 전체 테스트 시간이 예상보다 훨씬 길어질 수 있습니다. 특정 비즈니스 단계(로그인 → 상품 상세) 사이에만 전략적으로 배치하는 것이 좋습니다.